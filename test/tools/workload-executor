#!/usr/bin/env node

'use strict';
const MongoClient = require('../..').MongoClient;

let interrupted = false;
process.on('SIGINT', () => (interrupted = true));

async function main(uri, spec) {
  const runOperations = makeRunOperations(spec);
  const client = new MongoClient(uri, { useUnifiedTopology: true });
  await client.connect();

  let errorCount = 0;
  while (!interrupted) {
    try {
      await runOperations(client);
    } catch (err) {
      console.dir(err);
      errorCount++;
    }
  }

  await client.close();

  // output run statistics for test orchestrator
  console.error(JSON.stringify({ numErrors: errorCount }));

  // must exit with non-zero exit code if there was a failure
  process.exit(errorCount > 0 ? 1 : 0);
}

function makeRunOperations(spec) {
  const operations = spec.operations;
  // const db = client.db(spec.database_name);
  // const collection = db.collection(spec.collection_name);

  return function() {
    if (!Array.isArray(operations) || operations.length === 0) {
      return new Promise(resolve => setTimeout(resolve, 1000));
    }

    // reduce operations into
  };
}

const argv = require('yargs').command(
  '$0 <connectionString> <workloadSpecification>',
  '',
  yargs => {
    yargs
      .positional('connectionString', {
        describe: 'a connection string for the driver to connect to',
        type: 'string'
      })
      .positional('workloadSpecification', {
        describe: 'a JSON blob of operations to run during workload execution',
        type: 'string'
      });
  }
).argv;

const spec = JSON.parse(argv.workloadSpecification);
main(argv.connectionString, spec).catch(console.err);
