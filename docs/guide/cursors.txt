=======
Cursors
=======

When a driver executes a read that returns mutliple documents, the server does not immediately return all values that match the query. Instead, the driver creates a **Cursor** object which fetches the documents in batches.

Where are cursors used in the driver?
-------------------------------------

The following functions directly return cursors to the user:


* ``Collection.prototype.find``
* ``Collection.prototype.aggregate``
* ``Collection.prototype.listIndexes``
* ``Db.prototype.aggregate``
* ``Db.prototype.listCollections``

In addition, many other methods, like ``Collection.prototype.findOne`` and ``Collection.prototype.watch``\ , use cursors in order to return results.

How do I use a cursor?
----------------------

There are multiple ways to consume a cursor:

Stream API
^^^^^^^^^^

All cursors in the Node Driver are Node Readable Streams operating in Object Mode. Cursors will work with most Node stream APIs.

.. code-block:: js

   // defines a transform that calls JSON.stringify on the cursor's output
   class StringifyStream extends stream.Transform {
     constructor() {
       // Need this b/c cursors operate in objectMode
       super({ objectMode: true });
     }

     transform(chunk, _, callback) {
       // outputs each document as a stringified version, separated by newlines
       callback(null, `${JSON.stringify(chunk)}\n`);
     }
   }

   // Using the stream API to pipe to stdout
   const cursor1 = collection.find({});
   cursor1
     .pipe(new StringifyStream())
     .pipe(process.stdout);
   
   // Using the stream API to pipe to file 'my-output.txt'
   const cursor2 = collection.find({});
   cursor2
     .pipe(new StringifyStream())
     .pipe(fs.createWriteStream('my-output.txt'));

Event API
^^^^^^^^^

As Readable Streams, Cursors also support an Event API.

.. code-block:: js

   // Using the event API
   const cursor = collection.find({});
   cursor.on('data', data => console.log(data));

Get all documents at once
^^^^^^^^^^^^^^^^^^^^^^^^^

To get all documents at once, users can use the ``toArray`` method.

.. code-block:: js

   // Get all values
   const cursor = collection.find({});
   const allValues = await cursor.toArray();

Async Iterator
^^^^^^^^^^^^^^

Cursors also implement the AsyncIterator interface, allowing them to be used in ``for``...\ ``await`` loops.

.. code-block:: js

   const cursor = collection.find({});
   for await(const doc of cursor) {
     console.log(doc);
   }

For Each
^^^^^^^^

If you want to perform an operation on each document, you can use the ``forEach`` method.

.. code-block:: js

   // apply a callback to every item in a cursor
   const cursor = collection.find({});
   await cursor.forEach(doc => console.log(doc));

Manual Iteration
^^^^^^^^^^^^^^^^

If you wish manually iterate the cursor one document at a time, use ``next`` and ``hasNext``.

.. code-block:: js

   // get only one value
   const cursor = collection.find({});
   let firstValue, secondValue;
   if (await cursor.hasNext()) {
     firstValue = await cursor.next();
     if (await cursor.hasNext()) {
       secondValue = await cursor.next();
     }
   }

Important design considerations
-------------------------------

Only use one API at a time
^^^^^^^^^^^^^^^^^^^^^^^^^^

The cursor is designed with the assumption that users will only use one of the above methods to get data. Therefore, when interacting with a cursor, **it is very important to only use one method of interaction at a time**. Using more than one method of interacting with a cursor will lead to undefined behavior.

For example, the following:

.. code-block:: js

   const cursor = collection.find({});

   cursor.on('data', data => callSomeLoggingFunction(data));

   while (await cursor.hasNext()) {
     doSomethingWithDocument(await cursor.next());
   }

is very likely to cause an error as it attempts to use both the ``next``\ /\ ``hasNext`` API and the stream event API.

Do not attempt multiple simultaneous cursor operations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The cursor is designed with the assumption that it will only be performing one asynchronous operation at a time. Because of this, attempting multiple async operations in parallel on a cursor can result in undefined behavior.

For example, the following loop is likely to produce an error:

.. code-block:: js

   const promises = [];
   const cursor = collection.find({});

   for (let i = 0; i < 100; i++) {
     promises.push(cursor.next());
   }

   const results = await Promise.all(promises);

A cursor can be reaped if it is not used for a while
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If a cursor is inactive for a long enough time (default value of 10 minutes), the server may automatically close the cursor. Attempting to use the cursor after it has been closed can lead to an error. Users should be aware of this if they are performing operations that cause long waits between operations. For example:

.. code-block:: js

   const cursor = colleciton.find({});

   while (await cursor.hasNext()) {
     // Some long task that takes a long time (over 10 minutes)
     await doSomethingThatTakesAWhile();

     console.log(await cursor.next());
   }

In this case, if ``await doSomethingThatTakesAWhile();`` takes more than 10 minutes, the cursor may be reaped on the server, and the subsequent ``await cursor.next()`` call can result in an error.
